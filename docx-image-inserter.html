<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOCX Image & Infographic Inserter AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;900&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 50%, #16213e 100%);
            position: relative;
            overflow-x: hidden;
            min-height: 100vh;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(2px 2px at 20% 30%, rgba(0, 255, 255, 0.3), transparent),
                radial-gradient(2px 2px at 60% 70%, rgba(138, 43, 226, 0.3), transparent),
                radial-gradient(1px 1px at 50% 50%, rgba(255, 0, 255, 0.3), transparent),
                radial-gradient(1px 1px at 80% 10%, rgba(0, 191, 255, 0.3), transparent);
            background-size: 200px 200px, 300px 300px, 150px 150px, 250px 250px;
            animation: particleAnimation 20s linear infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes particleAnimation {
            0% { background-position: 0 0, 0 0, 0 0, 0 0; }
            100% { background-position: 200px 200px, -300px 300px, 150px -150px, -250px 250px; }
        }

        .container-main {
            position: relative;
            z-index: 1;
        }

        .glass-effect {
            background: rgba(26, 32, 53, 0.7);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 255, 255, 0.15);
        }

        .neon-border {
            position: relative;
            border: 2px solid transparent;
            background: linear-gradient(rgba(26, 32, 53, 0.9), rgba(26, 32, 53, 0.9)) padding-box,
                        linear-gradient(135deg, #00ffff, #8a2be2, #ff00ff) border-box;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3),
                        inset 0 0 20px rgba(138, 43, 226, 0.1);
        }

        .title-glow {
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8),
                         0 0 20px rgba(138, 43, 226, 0.6),
                         0 0 30px rgba(255, 0, 255, 0.4);
            animation: titlePulse 3s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { text-shadow: 0 0 10px rgba(0, 255, 255, 0.8), 0 0 20px rgba(138, 43, 226, 0.6); }
            50% { text-shadow: 0 0 20px rgba(0, 255, 255, 1), 0 0 40px rgba(138, 43, 226, 0.8); }
        }

        .loader {
            border: 4px solid rgba(0, 255, 255, 0.2);
            border-radius: 50%;
            border-top: 4px solid #00ffff;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .section-card {
            background: rgba(26, 32, 53, 0.6);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .section-card:hover {
            border-color: rgba(0, 255, 255, 0.5);
            box-shadow: 0 12px 40px rgba(0, 255, 255, 0.2);
        }

        .section-title {
            font-family: 'Orbitron', sans-serif;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            font-weight: 700;
        }

        label {
            color: #a0d8f1;
            font-weight: 500;
        }

        input, textarea, select {
            background: rgba(10, 14, 39, 0.8) !important;
            border: 1px solid rgba(0, 255, 255, 0.3) !important;
            color: #fff !important;
            transition: all 0.3s ease;
        }

        input:focus, textarea:focus, select:focus {
            outline: none !important;
            border-color: #00ffff !important;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.4) !important;
        }

        button {
            position: relative;
            overflow: hidden;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.4);
        }

        .btn-primary {
            background: linear-gradient(135deg, #00bfff, #8a2be2);
            box-shadow: 0 4px 15px rgba(0, 191, 255, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #8a2be2, #ff00ff);
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #00ff88, #00cc88);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.4);
        }

        .hidden { display: none !important; }

        .api-key-container {
            background: linear-gradient(135deg, rgba(0, 191, 255, 0.1), rgba(138, 43, 226, 0.1));
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .api-key-saved {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 204, 136, 0.1));
            border-color: rgba(0, 255, 136, 0.5);
        }

        .divider {
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ffff, transparent);
            margin: 1.5rem 0;
        }

        .eye-icon {
            cursor: pointer;
            color: #00ffff;
            transition: all 0.3s ease;
        }

        .eye-icon:hover {
            color: #8a2be2;
            transform: scale(1.1);
        }

        .chapter-item {
            background: rgba(10, 14, 39, 0.5);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: all 0.3s ease;
        }

        .chapter-item:hover {
            border-color: rgba(0, 255, 255, 0.5);
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.2);
        }

        .suggestion-item {
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 0.5rem;
        }

        .checkbox-custom {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #00ffff;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: rgba(10, 14, 39, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00bfff, #8a2be2, #ff00ff);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 14px;
        }

        .image-type-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .badge-image {
            background: linear-gradient(135deg, #00bfff, #0088cc);
            color: white;
        }

        .badge-infographic {
            background: linear-gradient(135deg, #ff00ff, #cc00cc);
            color: white;
        }

        .badge-diagram {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: white;
        }

        .badge-chart {
            background: linear-gradient(135deg, #ffaa00, #ff8800);
            color: white;
        }

        footer {
            background: rgba(10, 14, 39, 0.9);
            border-top: 2px solid rgba(0, 255, 255, 0.3);
            padding: 2rem;
            text-align: center;
            margin-top: 4rem;
            font-family: 'Orbitron', sans-serif;
            box-shadow: 0 -4px 20px rgba(0, 255, 255, 0.2);
        }

        .footer-text {
            font-size: 1.1rem;
            background: linear-gradient(135deg, #00ffff, #8a2be2, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
        }

        ::placeholder {
            color: rgba(160, 216, 241, 0.5) !important;
        }

        .status-message {
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
            font-weight: 500;
        }

        .status-success {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }

        .status-error {
            background: rgba(255, 0, 136, 0.1);
            border: 1px solid rgba(255, 0, 136, 0.3);
            color: #ff0088;
        }

        .status-info {
            background: rgba(0, 191, 255, 0.1);
            border: 1px solid rgba(0, 191, 255, 0.3);
            color: #00bfff;
        }
    </style>
</head>
<body class="flex justify-center items-start min-h-screen p-4 sm:p-6 lg:p-8">

    <div class="container-main w-full max-w-6xl mx-auto">

        <!-- API Key Section -->
        <div id="apiKeySection" class="api-key-container mb-6">
            <div class="flex items-center justify-between mb-3">
                <h3 class="section-title text-xl">üîë API Key Gemini</h3>
            </div>
            <div id="apiKeyInput" class="flex gap-3">
                <div class="relative flex-1">
                    <input type="password" id="apiKeyField" class="w-full px-4 py-3 rounded-lg font-mono text-sm" placeholder="Inserisci la tua API key di Google Gemini">
                    <span id="toggleApiKey" class="eye-icon absolute right-3 top-1/2 transform -translate-y-1/2">
                        üëÅÔ∏è
                    </span>
                </div>
                <button id="saveApiKeyBtn" class="btn-primary px-6 py-3 rounded-lg text-white">
                    Salva Key
                </button>
            </div>
            <div id="apiKeySaved" class="hidden mt-3 flex items-center justify-between">
                <div class="flex items-center gap-2">
                    <span class="text-green-400">‚úÖ</span>
                    <span class="text-green-300">API Key salvata con successo</span>
                </div>
                <button id="changeApiKeyBtn" class="text-cyan-400 hover:text-cyan-300 text-sm underline">
                    Modifica Key
                </button>
            </div>
        </div>

        <!-- Main Card -->
        <div class="glass-effect neon-border rounded-2xl p-6 sm:p-8">
            <div class="text-center mb-8">
                <h1 class="title-glow text-3xl sm:text-4xl font-bold mb-3">
                    DOCX IMAGE & INFOGRAPHIC INSERTER AI
                </h1>
                <div class="divider"></div>
                <p class="text-gray-300 text-lg mt-3">Analizza i tuoi documenti e inserisci automaticamente immagini e infografiche pertinenti.</p>
            </div>

            <!-- Step 1: Upload DOCX -->
            <div id="step1" class="section-card mb-6">
                <h2 class="section-title text-2xl mb-4">
                    <span class="text-2xl mr-2">üìÑ</span> Step 1: Carica il tuo Documento DOCX
                </h2>
                <div class="divider mb-4"></div>
                <div class="space-y-4">
                    <div>
                        <label for="docxFile" class="block text-sm font-medium mb-2">Seleziona file DOCX</label>
                        <input type="file" id="docxFile" accept=".docx" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-gradient-to-r file:from-cyan-500 file:to-purple-500 file:text-white hover:file:opacity-80 file:cursor-pointer">
                    </div>
                    <button id="analyzeBtn" class="btn-primary w-full text-white font-bold py-4 px-6 rounded-lg">
                        ‚ö° Analizza Documento
                    </button>
                    <div id="uploadStatus" class="hidden"></div>
                </div>
            </div>

            <!-- Step 2: Review Suggestions -->
            <div id="step2" class="section-card mb-6 hidden">
                <h2 class="section-title text-2xl mb-4">
                    <span class="text-2xl mr-2">üéØ</span> Step 2: Review Suggerimenti
                </h2>
                <div class="divider mb-4"></div>
                <p class="text-gray-300 mb-4">Seleziona le immagini/infografiche che vuoi generare:</p>
                <div id="suggestionsContainer" class="space-y-4">
                    <!-- Suggestions will be populated here -->
                </div>
                <div class="mt-6 flex gap-3">
                    <button id="selectAllBtn" class="btn-secondary flex-1 text-white font-bold py-3 px-6 rounded-lg">
                        ‚úì Seleziona Tutto
                    </button>
                    <button id="deselectAllBtn" class="btn-secondary flex-1 text-white font-bold py-3 px-6 rounded-lg">
                        ‚úó Deseleziona Tutto
                    </button>
                </div>
                <button id="generateBtn" class="btn-success w-full mt-4 text-white font-bold py-4 px-6 rounded-lg">
                    üé® Genera Immagini Selezionate
                </button>
            </div>

            <!-- Step 3: Generation Progress -->
            <div id="step3" class="section-card mb-6 hidden">
                <h2 class="section-title text-2xl mb-4">
                    <span class="text-2xl mr-2">‚öôÔ∏è</span> Step 3: Generazione in Corso
                </h2>
                <div class="divider mb-4"></div>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill" style="width: 0%;">0%</div>
                </div>
                <div id="progressStatus" class="mt-4 text-center text-gray-300"></div>
            </div>

            <!-- Step 4: Download -->
            <div id="step4" class="section-card mb-6 hidden">
                <h2 class="section-title text-2xl mb-4">
                    <span class="text-2xl mr-2">‚úÖ</span> Step 4: Documento Completato
                </h2>
                <div class="divider mb-4"></div>
                <p class="text-gray-300 mb-4">Il tuo documento con le immagini inserite √® pronto!</p>
                <button id="downloadBtn" class="btn-success w-full text-white font-bold py-4 px-6 rounded-lg">
                    üíæ Download Documento DOCX
                </button>
                <button id="resetBtn" class="btn-secondary w-full mt-3 text-white font-bold py-3 px-4 rounded-lg">
                    üîÑ Analizza Nuovo Documento
                </button>
            </div>

            <!-- Loader -->
            <div id="loaderSection" class="hidden flex flex-col items-center justify-center py-12">
                <div class="loader"></div>
                <p class="text-gray-300 mt-4" id="loaderText">Elaborazione in corso...</p>
            </div>
        </div>

        <!-- Footer -->
        <footer>
            <div class="footer-text text-2xl mb-2">
                AI OSHA √ó KARMA WRITERS
            </div>
            <div class="text-gray-400 text-sm">
                Powered by Gemini AI - Document Image Insertion
            </div>
        </footer>

    </div>

    <script>
        // State
        let apiKey = localStorage.getItem('geminiApiKey') || "";
        let documentData = null;
        let suggestions = [];
        let generatedImages = [];
        let originalDocxBuffer = null;

        // DOM Elements
        const apiKeyField = document.getElementById('apiKeyField');
        const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const apiKeySaved = document.getElementById('apiKeySaved');
        const changeApiKeyBtn = document.getElementById('changeApiKeyBtn');
        const toggleApiKey = document.getElementById('toggleApiKey');
        const apiKeySection = document.getElementById('apiKeySection');

        const docxFile = document.getElementById('docxFile');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const uploadStatus = document.getElementById('uploadStatus');

        const step1 = document.getElementById('step1');
        const step2 = document.getElementById('step2');
        const step3 = document.getElementById('step3');
        const step4 = document.getElementById('step4');
        const loaderSection = document.getElementById('loaderSection');
        const loaderText = document.getElementById('loaderText');

        const suggestionsContainer = document.getElementById('suggestionsContainer');
        const selectAllBtn = document.getElementById('selectAllBtn');
        const deselectAllBtn = document.getElementById('deselectAllBtn');
        const generateBtn = document.getElementById('generateBtn');

        const progressFill = document.getElementById('progressFill');
        const progressStatus = document.getElementById('progressStatus');

        const downloadBtn = document.getElementById('downloadBtn');
        const resetBtn = document.getElementById('resetBtn');

        // Initialize
        if (apiKey) {
            apiKeyInput.classList.add('hidden');
            apiKeySaved.classList.remove('hidden');
            apiKeySection.classList.add('api-key-saved');
        }

        // API Key Handlers
        saveApiKeyBtn.addEventListener('click', () => {
            const key = apiKeyField.value.trim();
            if (key) {
                apiKey = key;
                localStorage.setItem('geminiApiKey', key);
                apiKeyInput.classList.add('hidden');
                apiKeySaved.classList.remove('hidden');
                apiKeySection.classList.add('api-key-saved');
                showStatus(uploadStatus, 'API Key salvata con successo! ‚úÖ', 'success');
            } else {
                showStatus(uploadStatus, 'Per favore, inserisci una API key valida.', 'error');
            }
        });

        changeApiKeyBtn.addEventListener('click', () => {
            apiKeyField.value = '';
            apiKeyInput.classList.remove('hidden');
            apiKeySaved.classList.add('hidden');
            apiKeySection.classList.remove('api-key-saved');
        });

        toggleApiKey.addEventListener('click', () => {
            if (apiKeyField.type === 'password') {
                apiKeyField.type = 'text';
                toggleApiKey.textContent = 'üôà';
            } else {
                apiKeyField.type = 'password';
                toggleApiKey.textContent = 'üëÅÔ∏è';
            }
        });

        // Main Workflow
        analyzeBtn.addEventListener('click', analyzeDocument);
        selectAllBtn.addEventListener('click', () => toggleAllCheckboxes(true));
        deselectAllBtn.addEventListener('click', () => toggleAllCheckboxes(false));
        generateBtn.addEventListener('click', generateImages);
        downloadBtn.addEventListener('click', downloadDocument);
        resetBtn.addEventListener('click', resetApp);

        async function analyzeDocument() {
            if (!apiKey) {
                showStatus(uploadStatus, 'Per favore, inserisci prima la tua API key di Gemini.', 'error');
                return;
            }

            if (!docxFile.files[0]) {
                showStatus(uploadStatus, 'Per favore, seleziona un file DOCX.', 'error');
                return;
            }

            showLoader(true, 'Lettura del documento...');

            try {
                // Read DOCX file
                const file = docxFile.files[0];
                const arrayBuffer = await file.arrayBuffer();
                originalDocxBuffer = arrayBuffer;

                // Extract text using mammoth
                const result = await mammoth.extractRawText({ arrayBuffer });
                const fullText = result.value;

                if (!fullText || fullText.trim().length === 0) {
                    throw new Error('Il documento sembra essere vuoto.');
                }

                loaderText.textContent = 'Analisi del testo con AI...';

                // Split into chapters (simple heuristic: split by "Capitolo" or major headings)
                const chapters = splitIntoChapters(fullText);

                if (chapters.length === 0) {
                    throw new Error('Nessun capitolo trovato nel documento.');
                }

                // Analyze each chapter with AI
                suggestions = [];
                for (let i = 0; i < chapters.length; i++) {
                    loaderText.textContent = `Analisi capitolo ${i + 1} di ${chapters.length}...`;
                    const chapterSuggestions = await analyzeChapterWithAI(chapters[i], i + 1);
                    if (chapterSuggestions && chapterSuggestions.length > 0) {
                        suggestions.push(...chapterSuggestions);
                    }
                }

                if (suggestions.length === 0) {
                    showStatus(uploadStatus, 'Nessun suggerimento di immagine trovato. Il testo potrebbe non richiedere supporti visivi.', 'info');
                    showLoader(false);
                    return;
                }

                // Display suggestions
                displaySuggestions();

                showLoader(false);
                step1.classList.add('hidden');
                step2.classList.remove('hidden');

            } catch (error) {
                console.error('Error analyzing document:', error);
                showStatus(uploadStatus, `Errore: ${error.message}`, 'error');
                showLoader(false);
            }
        }

        function splitIntoChapters(text) {
            // Simple chapter detection: split by common patterns
            // This is a basic implementation - can be improved
            const chapterPatterns = [
                /(?:^|\n)(?:Capitolo|Chapter|CAPITOLO|CHAPTER)\s+(\d+|[IVXLCDM]+)[:\s\.\-]+(.*?)(?=(?:\n(?:Capitolo|Chapter|CAPITOLO|CHAPTER)|\n*$))/gis,
                /(?:^|\n)(#{1,2}\s+.*?)(?=\n#{1,2}\s+|\n*$)/gis
            ];

            let chapters = [];

            // Try to match chapter patterns
            for (const pattern of chapterPatterns) {
                const matches = [...text.matchAll(pattern)];
                if (matches.length > 0) {
                    chapters = matches.map((match, index) => ({
                        number: index + 1,
                        title: match[2] || match[1] || `Capitolo ${index + 1}`,
                        content: match[0]
                    }));
                    break;
                }
            }

            // If no chapters found, split by paragraphs or create single chapter
            if (chapters.length === 0) {
                const paragraphs = text.split(/\n\n+/);
                if (paragraphs.length > 5) {
                    // Group paragraphs into pseudo-chapters
                    const chunkSize = Math.ceil(paragraphs.length / 5);
                    for (let i = 0; i < paragraphs.length; i += chunkSize) {
                        chapters.push({
                            number: Math.floor(i / chunkSize) + 1,
                            title: `Sezione ${Math.floor(i / chunkSize) + 1}`,
                            content: paragraphs.slice(i, i + chunkSize).join('\n\n')
                        });
                    }
                } else {
                    // Treat entire document as one chapter
                    chapters = [{
                        number: 1,
                        title: 'Documento Completo',
                        content: text
                    }];
                }
            }

            return chapters;
        }

        async function analyzeChapterWithAI(chapter, chapterNumber) {
            const prompt = `Sei un esperto di design editoriale. Analizza il seguente testo e identifica DOVE inserire immagini o infografiche per rendere il contenuto pi√π comprensibile e visivamente accattivante.

IMPORTANTE: Devi suggerire ALMENO 1 e MASSIMO 8 immagini/infografiche per questo capitolo.

Cerca opportunit√† per visualizzare:
- Concetti astratti che possono essere illustrati
- Processi o sequenze che possono diventare diagrammi di flusso
- Dati o statistiche che possono essere grafici
- Scene o ambientazioni che possono essere illustrate
- Confronti che possono diventare tabelle visive
- Esempi pratici che meritano un'illustrazione
- Momenti chiave della narrazione
- Metafore o simboli che possono essere rappresentati visivamente

Per OGNI suggerimento fornisci:
1. TIPO: scegli tra "immagine", "infografica", "diagramma", "grafico"
2. POSIZIONE: "inizio", "met√†", o "fine" del capitolo
3. DESCRIPTION: descrizione dettagliata e specifica di cosa rappresentare
4. REASON: spiega perch√© migliora la comprensione
5. TEXT_CONTENT: se l'immagine deve contenere testo (es. infografica, diagramma), specifica ESATTAMENTE il testo da includere

Rispondi SOLO in formato JSON valido:
[
  {
    "type": "infografica",
    "position": "inizio",
    "description": "Infografica che mostra i 5 passi del processo",
    "reason": "Fornisce una panoramica visiva immediata",
    "textContent": "Passo 1: Analisi|Passo 2: Pianificazione|Passo 3: Esecuzione|Passo 4: Verifica|Passo 5: Ottimizzazione",
    "chapter": ${chapterNumber},
    "chapterTitle": "${chapter.title}"
  }
]

REGOLE:
- Minimo 1 suggerimento, massimo 8 suggerimenti
- Sii creativo e proattivo nel trovare opportunit√† visive
- Preferisci la variet√†: alterna immagini, infografiche, diagrammi, grafici
- Se non c'√® testo da includere, usa "textContent": ""

Testo del capitolo:
---
${chapter.content.substring(0, 5000)}
---`;

            try {
                const response = await callGeminiTextAPI(prompt);

                // Extract JSON from response
                let jsonMatch = response.match(/\[[\s\S]*\]/);
                if (!jsonMatch) {
                    console.warn('No JSON array found in AI response for chapter', chapterNumber);
                    return [];
                }

                const parsed = JSON.parse(jsonMatch[0]);
                return parsed.map(item => ({
                    ...item,
                    chapter: chapterNumber,
                    chapterTitle: chapter.title,
                    selected: false
                }));

            } catch (error) {
                console.error('Error analyzing chapter with AI:', error);
                return [];
            }
        }

        async function callGeminiTextAPI(prompt) {
            if (!apiKey) {
                throw new Error('API key non configurata');
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{
                    parts: [{ text: prompt }]
                }],
                generationConfig: {
                    temperature: 0.7,
                    maxOutputTokens: 2048
                }
            };

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`API request failed: ${response.status}`);
            }

            const result = await response.json();

            if (!result.candidates || result.candidates.length === 0) {
                throw new Error('No response from AI');
            }

            return result.candidates[0].content.parts[0].text;
        }

        async function callGeminiImageAPI(prompt) {
            if (!apiKey) {
                throw new Error('API key non configurata');
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{
                    parts: [{ text: prompt }]
                }],
                generationConfig: {
                    responseModalities: ['TEXT', 'IMAGE']
                }
            };

            let attempts = 0;
            let delay = 1000;

            while (attempts < 5) {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    const result = await response.json();

                    if (!result.candidates || result.candidates.length === 0) {
                        throw new Error('No image generated by AI');
                    }

                    const candidate = result.candidates[0];
                    const base64Data = candidate.content?.parts?.find(p => p.inlineData)?.inlineData?.data;

                    if (!base64Data) {
                        throw new Error('No image data in response');
                    }

                    return `data:image/png;base64,${base64Data}`;
                }

                if (response.status === 429 || response.status >= 500) {
                    console.warn(`Request failed with status ${response.status}. Retrying in ${delay / 1000}s...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                    attempts++;
                } else {
                    throw new Error(`API request failed: ${response.status}`);
                }
            }

            throw new Error('Failed after multiple retries');
        }

        function displaySuggestions() {
            suggestionsContainer.innerHTML = '';

            const groupedByChapter = {};
            suggestions.forEach((suggestion, index) => {
                suggestion.id = index;
                if (!groupedByChapter[suggestion.chapter]) {
                    groupedByChapter[suggestion.chapter] = [];
                }
                groupedByChapter[suggestion.chapter].push(suggestion);
            });

            Object.keys(groupedByChapter).sort((a, b) => a - b).forEach(chapter => {
                const chapterDiv = document.createElement('div');
                chapterDiv.className = 'chapter-item';

                const chapterTitle = groupedByChapter[chapter][0].chapterTitle;
                chapterDiv.innerHTML = `
                    <h3 class="section-title text-lg mb-3">
                        üìñ Capitolo ${chapter}: ${chapterTitle}
                    </h3>
                    <div class="space-y-2" id="chapter-${chapter}-suggestions"></div>
                `;

                suggestionsContainer.appendChild(chapterDiv);

                const suggestionsDiv = document.getElementById(`chapter-${chapter}-suggestions`);
                groupedByChapter[chapter].forEach(suggestion => {
                    const suggestionDiv = document.createElement('div');
                    suggestionDiv.className = 'suggestion-item flex items-start gap-3';

                    const badgeClass = `badge-${suggestion.type}`;
                    const textContentHtml = suggestion.textContent && suggestion.textContent.trim()
                        ? `<p class="text-cyan-300 text-sm mt-1"><strong>üìù Testo da includere:</strong> ${suggestion.textContent}</p>`
                        : '';

                    suggestionDiv.innerHTML = `
                        <input type="checkbox" class="checkbox-custom mt-1" data-suggestion-id="${suggestion.id}">
                        <div class="flex-1">
                            <div class="flex items-center gap-2 mb-2">
                                <span class="image-type-badge ${badgeClass}">${suggestion.type}</span>
                                <span class="text-gray-400 text-sm">‚Ä¢ ${suggestion.position}</span>
                            </div>
                            <p class="text-gray-200 mb-1"><strong>Descrizione:</strong> ${suggestion.description}</p>
                            <p class="text-gray-400 text-sm"><strong>Motivo:</strong> ${suggestion.reason}</p>
                            ${textContentHtml}
                        </div>
                    `;

                    suggestionsDiv.appendChild(suggestionDiv);
                });
            });
        }

        function toggleAllCheckboxes(checked) {
            document.querySelectorAll('.checkbox-custom').forEach(cb => cb.checked = checked);
        }

        async function generateImages() {
            const selectedCheckboxes = document.querySelectorAll('.checkbox-custom:checked');

            if (selectedCheckboxes.length === 0) {
                alert('Seleziona almeno un\'immagine da generare.');
                return;
            }

            const selectedIds = Array.from(selectedCheckboxes).map(cb => parseInt(cb.dataset.suggestionId));
            const selectedSuggestions = suggestions.filter(s => selectedIds.includes(s.id));

            step2.classList.add('hidden');
            step3.classList.remove('hidden');

            generatedImages = [];
            const total = selectedSuggestions.length;

            for (let i = 0; i < selectedSuggestions.length; i++) {
                const suggestion = selectedSuggestions[i];
                const progress = Math.round(((i + 1) / total) * 100);

                progressFill.style.width = `${progress}%`;
                progressFill.textContent = `${progress}%`;
                progressStatus.textContent = `Generazione ${i + 1} di ${total}: ${suggestion.type} per "${suggestion.chapterTitle}"...`;

                try {
                    const imagePrompt = createImagePrompt(suggestion);
                    const imageData = await callGeminiImageAPI(imagePrompt);

                    generatedImages.push({
                        suggestion,
                        imageData,
                        chapter: suggestion.chapter
                    });

                } catch (error) {
                    console.error('Error generating image:', error);
                    progressStatus.textContent = `Errore generando immagine ${i + 1}. Continuando...`;
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }

            if (generatedImages.length === 0) {
                alert('Nessuna immagine √® stata generata con successo.');
                step3.classList.add('hidden');
                step2.classList.remove('hidden');
                return;
            }

            progressFill.style.width = '100%';
            progressFill.textContent = '100%';
            progressStatus.textContent = 'Tutte le immagini generate! Preparazione documento...';

            await new Promise(resolve => setTimeout(resolve, 1000));

            await insertImagesIntoDocument();

            step3.classList.add('hidden');
            step4.classList.remove('hidden');
        }

        function createImagePrompt(suggestion) {
            let prompt = '';
            const hasText = suggestion.textContent && suggestion.textContent.trim() !== '';

            switch (suggestion.type) {
                case 'immagine':
                    prompt = `Crea un'immagine professionale e di alta qualit√† che rappresenti: ${suggestion.description}.

REQUISITI FONDAMENTALI:
- Stile: fotografico, realistico, adatto per un documento professionale
- Composizione: bilanciata e chiara
- Qualit√†: alta risoluzione, nitida
- Colori: armoniosi e professionali`;
                    break;

                case 'infografica':
                    prompt = `Crea un'infografica professionale che illustri: ${suggestion.description}.

REQUISITI FONDAMENTALI PER IL TESTO:
- Il testo DEVE essere PERFETTAMENTE leggibile e senza errori
- Font: Sans-serif moderno, pulito, professionale
- Dimensione testo: Grande e chiara
- Contrasto: Alto contrasto tra testo e sfondo
- Allineamento: Perfetto e ordinato
- Ortografia: ZERO errori, testo ESATTAMENTE come specificato

STILE VISIVO:
- Design: Moderno, minimalista, professionale
- Layout: Pulito con ampio spazio bianco
- Colori: Palette armoniosa (max 3-4 colori)
- Icone: Semplici e chiare
- Gerarchia visiva: Chiara e intuitiva`;

                    if (hasText) {
                        prompt += `\n\nTESTO DA INCLUDERE (copialo ESATTAMENTE cos√¨):\n${suggestion.textContent}`;
                    }
                    break;

                case 'diagramma':
                    prompt = `Crea un diagramma tecnico e schematico che mostri: ${suggestion.description}.

REQUISITI FONDAMENTALI PER IL TESTO:
- Tutte le etichette devono essere PERFETTAMENTE leggibili
- Font: Sans-serif, chiaro, dimensione adeguata
- Ogni elemento deve avere un'etichetta chiara
- Zero errori di ortografia
- Testo ESATTAMENTE come specificato

STILE DIAGRAMMA:
- Linee: Nitide, uniformi, ben definite
- Forme: Geometriche precise
- Frecce: Chiare e direzionali
- Connessioni: Ben visibili
- Layout: Logico e ordinato
- Sfondo: Bianco o neutro`;

                    if (hasText) {
                        prompt += `\n\nETICHETTE E TESTO (usa ESATTAMENTE questo testo):\n${suggestion.textContent}`;
                    }
                    break;

                case 'grafico':
                    prompt = `Crea un grafico professionale (barre, linee, o torta) che visualizzi: ${suggestion.description}.

REQUISITI FONDAMENTALI PER IL TESTO:
- Tutti i numeri, etichette e legende devono essere PERFETTAMENTE leggibili
- Font: Sans-serif professionale
- Assi: Chiaramente etichettati
- Valori: Precisi e leggibili
- Leggenda: Chiara e ben posizionata
- Zero errori nei numeri o testi

STILE GRAFICO:
- Tipo: Scegli il pi√π appropriato (barre/linee/torta)
- Colori: Distinti e professionali
- Griglie: Sottili ma visibili
- Dati: Chiari e ben rappresentati
- Sfondo: Bianco o neutro
- Etichette: Tutte presenti e leggibili`;

                    if (hasText) {
                        prompt += `\n\nDATI E ETICHETTE (usa ESATTAMENTE questi valori):\n${suggestion.textContent}`;
                    }
                    break;
            }

            prompt += `\n\n‚ö†Ô∏è REGOLE CRITICHE:
1. Se c'√® testo specificato, copialo ESATTAMENTE senza modifiche
2. Zero errori di ortografia o grammatica
3. Testo sempre leggibile al 100%
4. Massima qualit√† professionale
5. Genera SOLO l'immagine richiesta, niente elementi extra

Motivazione del design: ${suggestion.reason}`;

            return prompt;
        }

        async function insertImagesIntoDocument() {
            try {
                // For now, we'll create a new document with the images
                // In a production environment, you'd want to modify the original DOCX

                // This is a simplified version - creating a new document with images
                const { Document, Packer, Paragraph, TextRun, ImageRun, HeadingLevel } = docx;

                const children = [];

                // Group images by chapter
                const imagesByChapter = {};
                generatedImages.forEach(img => {
                    if (!imagesByChapter[img.chapter]) {
                        imagesByChapter[img.chapter] = [];
                    }
                    imagesByChapter[img.chapter].push(img);
                });

                // Add title
                children.push(
                    new Paragraph({
                        text: "Documento con Immagini Generate",
                        heading: HeadingLevel.TITLE
                    }),
                    new Paragraph({ text: "" })
                );

                // Add images organized by chapter
                Object.keys(imagesByChapter).sort((a, b) => a - b).forEach(chapter => {
                    const chapterImages = imagesByChapter[chapter];
                    const chapterTitle = chapterImages[0].suggestion.chapterTitle;

                    children.push(
                        new Paragraph({
                            text: `Capitolo ${chapter}: ${chapterTitle}`,
                            heading: HeadingLevel.HEADING_1
                        }),
                        new Paragraph({ text: "" })
                    );

                    chapterImages.forEach((img, index) => {
                        // Add description
                        children.push(
                            new Paragraph({
                                children: [
                                    new TextRun({
                                        text: `${img.suggestion.type.toUpperCase()}: ${img.suggestion.description}`,
                                        bold: true
                                    })
                                ]
                            })
                        );

                        // Add image
                        try {
                            // Convert base64 to blob
                            const base64Data = img.imageData.split(',')[1];
                            const binaryData = atob(base64Data);
                            const bytes = new Uint8Array(binaryData.length);
                            for (let i = 0; i < binaryData.length; i++) {
                                bytes[i] = binaryData.charCodeAt(i);
                            }

                            children.push(
                                new Paragraph({
                                    children: [
                                        new ImageRun({
                                            data: bytes,
                                            transformation: {
                                                width: 500,
                                                height: 375
                                            }
                                        })
                                    ]
                                }),
                                new Paragraph({ text: "" })
                            );
                        } catch (error) {
                            console.error('Error adding image to document:', error);
                        }
                    });

                    children.push(new Paragraph({ text: "" }));
                });

                // Create document
                const doc = new Document({
                    sections: [{
                        properties: {},
                        children: children
                    }]
                });

                // Generate blob
                const blob = await Packer.toBlob(doc);
                documentData = blob;

            } catch (error) {
                console.error('Error inserting images into document:', error);
                alert('Errore durante l\'inserimento delle immagini nel documento.');
            }
        }

        function downloadDocument() {
            if (!documentData) {
                alert('Nessun documento disponibile per il download.');
                return;
            }

            const link = document.createElement('a');
            link.href = URL.createObjectURL(documentData);
            link.download = 'documento_con_immagini.docx';
            link.click();
            URL.revokeObjectURL(link.href);
        }

        function resetApp() {
            documentData = null;
            suggestions = [];
            generatedImages = [];
            originalDocxBuffer = null;

            docxFile.value = '';
            uploadStatus.innerHTML = '';
            uploadStatus.classList.add('hidden');

            step1.classList.remove('hidden');
            step2.classList.add('hidden');
            step3.classList.add('hidden');
            step4.classList.add('hidden');

            progressFill.style.width = '0%';
            progressFill.textContent = '0%';
            progressStatus.textContent = '';
        }

        function showLoader(show, text = 'Elaborazione in corso...') {
            loaderSection.classList.toggle('hidden', !show);
            loaderText.textContent = text;
        }

        function showStatus(element, message, type) {
            element.className = `status-message status-${type}`;
            element.textContent = message;
            element.classList.remove('hidden');
        }

    </script>
</body>
</html>
